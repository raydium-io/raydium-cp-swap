import * as anchor from "@coral-xyz/anchor";
import { Program, BN, web3 } from "@coral-xyz/anchor";
import { RaydiumCpSwap } from "../target/types/raydium_cp_swap";
import {
  createAmmConfig,
  initialize,
  deposit,
  swap_base_output,
} from "./utils/instruction";
import { assert } from "chai";
import {
  getAccount,
  getAssociatedTokenAddressSync,
  TOKEN_2022_PROGRAM_ID,
  createMint,
  TOKEN_PROGRAM_ID,
  getOrCreateAssociatedTokenAccount,
  mintTo,
  ExtensionType,
  getMintLen,
  createInitializeTransferFeeConfigInstruction,
  createInitializeMintInstruction,
} from "@solana/spl-token";
import { Keypair, Signer, Connection, SystemProgram, Transaction, sendAndConfirmTransaction, PublicKey } from "@solana/web3.js";

async function createMintWithTransferFee(
  connection: Connection,
  payer: Signer,
  mintAuthority: Signer,
  mintKeypair = Keypair.generate(),
  transferFeeConfig: { transferFeeBasisPoints: number; MaxFee: bigint },
  feeCollector: Keypair
) {
  const withdrawWithheldAuthority = feeCollector;

  const extensions = [ExtensionType.TransferFeeConfig];
  const mintLen = getMintLen(extensions);
  const decimals = 9;

  const mintLamports = await connection.getMinimumBalanceForRentExemption(
    mintLen
  );
  const mintTransaction = new Transaction().add(
    SystemProgram.createAccount({
      fromPubkey: payer.publicKey,
      newAccountPubkey: mintKeypair.publicKey,
      space: mintLen,
      lamports: mintLamports,
      programId: TOKEN_2022_PROGRAM_ID,
    }),
    createInitializeTransferFeeConfigInstruction(
      mintKeypair.publicKey,
      payer.publicKey, // transfer fee config authority
      withdrawWithheldAuthority.publicKey, // withdraw authority
      transferFeeConfig.transferFeeBasisPoints,
      transferFeeConfig.MaxFee,
      TOKEN_2022_PROGRAM_ID
    ),
    createInitializeMintInstruction(
      mintKeypair.publicKey,
      decimals,
      mintAuthority.publicKey,
      null,
      TOKEN_2022_PROGRAM_ID
    )
  );
  await sendAndConfirmTransaction(
    connection,
    mintTransaction,
    [payer, mintKeypair],
    {skipPreflight: true}
  );

  return mintKeypair.publicKey;
}

async function setupExploitTest(
  program: Program<RaydiumCpSwap>,
  connection: Connection,
  owner: Signer
) {
  const configAddress = await createAmmConfig(
    program,
    connection,
    owner,
    11, // new config index to avoid conflicts
    new BN(10),
    new BN(1000),
    new BN(25000),
    new BN(0)
  );

  // Token A: Regular SPL Token (Mock USDC)
  const usdcMint = await createMint(
    connection,
    owner,
    owner.publicKey,
    null,
    9
  );

  // Token B: Malicious Token-2022 with 100% transfer fee
  const feeCollector = Keypair.generate();
  const maliciousMint = await createMintWithTransferFee(
    connection,
    owner,
    owner,
    Keypair.generate(),
    {
      transferFeeBasisPoints: 10000, // 100%
      MaxFee: BigInt(1), // 1 lamport
    },
    feeCollector
  );

  // Create ATAs for owner and mint tokens
  const ownerUsdcAta = await getOrCreateAssociatedTokenAccount(connection, owner, usdcMint, owner.publicKey);
  const ownerMaliciousAta = await getOrCreateAssociatedTokenAccount(connection, owner, maliciousMint, owner.publicKey, false, "processed", undefined, TOKEN_2022_PROGRAM_ID);

  await mintTo(connection, owner, usdcMint, ownerUsdcAta.address, owner, BigInt(1_000_000 * 1e9));
  await mintTo(connection, owner, maliciousMint, ownerMaliciousAta.address, owner, BigInt(1_000_000 * 1e9), [], {skipPreflight: true}, TOKEN_2022_PROGRAM_ID);

  // Ensure tokens are ordered correctly for pool creation
  let token0, token0Program, token1, token1Program;
  if (usdcMint.toBuffer().compare(maliciousMint.toBuffer()) < 0) {
    token0 = usdcMint;
    token0Program = TOKEN_PROGRAM_ID;
    token1 = maliciousMint;
    token1Program = TOKEN_2022_PROGRAM_ID;
  } else {
    token0 = maliciousMint;
    token0Program = TOKEN_2022_PROGRAM_ID;
    token1 = usdcMint;
    token1Program = TOKEN_PROGRAM_ID;
  }

  const { poolAddress, poolState } = await initialize(
    program,
    owner,
    configAddress,
    token0,
    token0Program,
    token1,
    token1Program,
    {skipPreflight: true},
    { initAmount0: new BN(100 * 1e9), initAmount1: new BN(100 * 1e9) }
  );

  await deposit(
    program,
    owner,
    poolState.ammConfig,
    poolState.token0Mint,
    poolState.token0Program,
    poolState.token1Mint,
    poolState.token1Program,
    new BN(100 * 1e9),
    new BN(100 * 1e9),
    new BN(100 * 1e9),
    {skipPreflight: true}
  );

  return { configAddress, poolAddress, poolState, usdcMint, maliciousMint, feeCollector };
}


describe("exploit test", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const owner = anchor.Wallet.local().payer;
  const connection = anchor.getProvider().connection;

  const program = anchor.workspace.RaydiumCpSwap as Program<RaydiumCpSwap>;

  const confirmOptions = {
    skipPreflight: true,
  };

  it("fails to swap with a malicious token after fix", async () => {
    const { poolAddress, poolState, usdcMint, maliciousMint } = await setupExploitTest(program, connection, owner);

    // Attacker wants to receive 100 USDC by paying with the malicious token
    const amount_out_usdc = new BN(100 * 1e9);
    const max_amount_in_malicious = new BN(1_000_000 * 1e9); // A large number

    let failed = false;
    try {
        await swap_base_output(
          program,
          owner,
          poolState.ammConfig,
          maliciousMint,
          TOKEN_2022_PROGRAM_ID,
          usdcMint,
          TOKEN_PROGRAM_ID,
          amount_out_usdc,
          max_amount_in_malicious,
          confirmOptions,
          poolAddress
        );
    } catch (e) {
        // The transaction should fail because of our fix in `get_transfer_inverse_fee`
        const error = e as anchor.AnchorError;
        // 6025 is InvalidInput from our error.rs
        assert.equal(error.error.errorCode.code, "InvalidInput", "Transaction should fail with InvalidInput error");
        failed = true;
    }
    assert.isTrue(failed, "Transaction should have failed but it succeeded");
  });
});
